{"version":3,"file":"completions.js","sourceRoot":"","sources":["../../../../../packages/language-service/src/completions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, AstPath, AttrAst, Attribute, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, CssSelector, DirectiveAst, Element, ElementAst, EmbeddedTemplateAst, ImplicitReceiver, NAMED_ENTITIES, NgContentAst, Node as HtmlAst, NullTemplateVisitor, ParseSpan, PropertyRead, ReferenceAst, SelectorMatcher, TagContentType, TemplateAst, TemplateAstVisitor, Text, TextAst, VariableAst, findNode, getHtmlTagDefinition, splitNsName, templateVisitAll} from '@angular/compiler';\nimport {DiagnosticTemplateInfo, getExpressionScope} from '@angular/compiler-cli/src/language_services';\n\nimport {AstResult, AttrInfo, SelectorInfo, TemplateInfo} from './common';\nimport {getExpressionCompletions} from './expressions';\nimport {attributeNames, elementNames, eventNames, propertyNames} from './html_info';\nimport {BuiltinType, Completion, Completions, Span, Symbol, SymbolDeclaration, SymbolTable, TemplateSource} from './types';\nimport {diagnosticInfoFromTemplateInfo, findTemplateAstAt, flatten, getSelectors, hasTemplateReference, inSpan, removeSuffix, spanOf, uniqueByName} from './utils';\n\nconst TEMPLATE_ATTR_PREFIX = '*';\n\nconst hiddenHtmlElements = {\n  html: true,\n  script: true,\n  noscript: true,\n  base: true,\n  body: true,\n  title: true,\n  head: true,\n  link: true,\n};\n\nexport function getTemplateCompletions(templateInfo: TemplateInfo): Completions|undefined {\n  let result: Completions|undefined = undefined;\n  let {htmlAst, templateAst, template} = templateInfo;\n  // The templateNode starts at the delimiter character so we add 1 to skip it.\n  if (templateInfo.position != null) {\n    let templatePosition = templateInfo.position - template.span.start;\n    let path = findNode(htmlAst, templatePosition);\n    let mostSpecific = path.tail;\n    if (path.empty || !mostSpecific) {\n      result = elementCompletions(templateInfo, path);\n    } else {\n      let astPosition = templatePosition - mostSpecific.sourceSpan.start.offset;\n      mostSpecific.visit(\n          {\n            visitElement(ast) {\n              let startTagSpan = spanOf(ast.sourceSpan);\n              let tagLen = ast.name.length;\n              if (templatePosition <=\n                  startTagSpan.start + tagLen + 1 /* 1 for the opening angle bracked */) {\n                // If we are in the tag then return the element completions.\n                result = elementCompletions(templateInfo, path);\n              } else if (templatePosition < startTagSpan.end) {\n                // We are in the attribute section of the element (but not in an attribute).\n                // Return the attribute completions.\n                result = attributeCompletions(templateInfo, path);\n              }\n            },\n            visitAttribute(ast) {\n              if (!ast.valueSpan || !inSpan(templatePosition, spanOf(ast.valueSpan))) {\n                // We are in the name of an attribute. Show attribute completions.\n                result = attributeCompletions(templateInfo, path);\n              } else if (ast.valueSpan && inSpan(templatePosition, spanOf(ast.valueSpan))) {\n                result = attributeValueCompletions(templateInfo, templatePosition, ast);\n              }\n            },\n            visitText(ast) {\n              // Check if we are in a entity.\n              result = entityCompletions(getSourceText(template, spanOf(ast)), astPosition);\n              if (result) return result;\n              result = interpolationCompletions(templateInfo, templatePosition);\n              if (result) return result;\n              let element = path.first(Element);\n              if (element) {\n                let definition = getHtmlTagDefinition(element.name);\n                if (definition.contentType === TagContentType.PARSABLE_DATA) {\n                  result = voidElementAttributeCompletions(templateInfo, path);\n                  if (!result) {\n                    // If the element can hold content Show element completions.\n                    result = elementCompletions(templateInfo, path);\n                  }\n                }\n              } else {\n                // If no element container, implies parsable data so show elements.\n                result = voidElementAttributeCompletions(templateInfo, path);\n                if (!result) {\n                  result = elementCompletions(templateInfo, path);\n                }\n              }\n            },\n            visitComment(ast) {},\n            visitExpansion(ast) {},\n            visitExpansionCase(ast) {}\n          },\n          null);\n    }\n  }\n  return result;\n}\n\nfunction attributeCompletions(info: TemplateInfo, path: AstPath<HtmlAst>): Completions|undefined {\n  let item = path.tail instanceof Element ? path.tail : path.parentOf(path.tail);\n  if (item instanceof Element) {\n    return attributeCompletionsForElement(info, item.name, item);\n  }\n  return undefined;\n}\n\nfunction attributeCompletionsForElement(\n    info: TemplateInfo, elementName: string, element?: Element): Completions {\n  const attributes = getAttributeInfosForElement(info, elementName, element);\n\n  // Map all the attributes to a completion\n  return attributes.map<Completion>(attr => ({\n                                      kind: attr.fromHtml ? 'html attribute' : 'attribute',\n                                      name: nameOfAttr(attr),\n                                      sort: attr.name\n                                    }));\n}\n\nfunction getAttributeInfosForElement(\n    info: TemplateInfo, elementName: string, element?: Element): AttrInfo[] {\n  let attributes: AttrInfo[] = [];\n\n  // Add html attributes\n  let htmlAttributes = attributeNames(elementName) || [];\n  if (htmlAttributes) {\n    attributes.push(...htmlAttributes.map<AttrInfo>(name => ({name, fromHtml: true})));\n  }\n\n  // Add html properties\n  let htmlProperties = propertyNames(elementName);\n  if (htmlProperties) {\n    attributes.push(...htmlProperties.map<AttrInfo>(name => ({name, input: true})));\n  }\n\n  // Add html events\n  let htmlEvents = eventNames(elementName);\n  if (htmlEvents) {\n    attributes.push(...htmlEvents.map<AttrInfo>(name => ({name, output: true})));\n  }\n\n  let {selectors, map: selectorMap} = getSelectors(info);\n  if (selectors && selectors.length) {\n    // All the attributes that are selectable should be shown.\n    const applicableSelectors =\n        selectors.filter(selector => !selector.element || selector.element == elementName);\n    const selectorAndAttributeNames =\n        applicableSelectors.map(selector => ({selector, attrs: selector.attrs.filter(a => !!a)}));\n    let attrs = flatten(selectorAndAttributeNames.map<AttrInfo[]>(selectorAndAttr => {\n      const directive = selectorMap.get(selectorAndAttr.selector) !;\n      const result = selectorAndAttr.attrs.map<AttrInfo>(\n          name => ({name, input: name in directive.inputs, output: name in directive.outputs}));\n      return result;\n    }));\n\n    // Add template attribute if a directive contains a template reference\n    selectorAndAttributeNames.forEach(selectorAndAttr => {\n      const selector = selectorAndAttr.selector;\n      const directive = selectorMap.get(selector);\n      if (directive && hasTemplateReference(directive.type) && selector.attrs.length &&\n          selector.attrs[0]) {\n        attrs.push({name: selector.attrs[0], template: true});\n      }\n    });\n\n    // All input and output properties of the matching directives should be added.\n    let elementSelector = element ?\n        createElementCssSelector(element) :\n        createElementCssSelector(new Element(elementName, [], [], null !, null, null));\n\n    let matcher = new SelectorMatcher();\n    matcher.addSelectables(selectors);\n    matcher.match(elementSelector, selector => {\n      let directive = selectorMap.get(selector);\n      if (directive) {\n        attrs.push(...Object.keys(directive.inputs).map(name => ({name, input: true})));\n        attrs.push(...Object.keys(directive.outputs).map(name => ({name, output: true})));\n      }\n    });\n\n    // If a name shows up twice, fold it into a single value.\n    attrs = foldAttrs(attrs);\n\n    // Now expand them back out to ensure that input/output shows up as well as input and\n    // output.\n    attributes.push(...flatten(attrs.map(expandedAttr)));\n  }\n  return attributes;\n}\n\nfunction attributeValueCompletions(\n    info: TemplateInfo, position: number, attr: Attribute): Completions|undefined {\n  const path = findTemplateAstAt(info.templateAst, position);\n  const mostSpecific = path.tail;\n  const dinfo = diagnosticInfoFromTemplateInfo(info);\n  if (mostSpecific) {\n    const visitor =\n        new ExpressionVisitor(info, position, attr, () => getExpressionScope(dinfo, path, false));\n    mostSpecific.visit(visitor, null);\n    if (!visitor.result || !visitor.result.length) {\n      // Try allwoing widening the path\n      const widerPath = findTemplateAstAt(info.templateAst, position, /* allowWidening */ true);\n      if (widerPath.tail) {\n        const widerVisitor = new ExpressionVisitor(\n            info, position, attr, () => getExpressionScope(dinfo, widerPath, false));\n        widerPath.tail.visit(widerVisitor, null);\n        return widerVisitor.result;\n      }\n    }\n    return visitor.result;\n  }\n}\n\nfunction elementCompletions(info: TemplateInfo, path: AstPath<HtmlAst>): Completions|undefined {\n  let htmlNames = elementNames().filter(name => !(name in hiddenHtmlElements));\n\n  // Collect the elements referenced by the selectors\n  let directiveElements = getSelectors(info)\n                              .selectors.map(selector => selector.element)\n                              .filter(name => !!name) as string[];\n\n  let components =\n      directiveElements.map<Completion>(name => ({kind: 'component', name, sort: name}));\n  let htmlElements = htmlNames.map<Completion>(name => ({kind: 'element', name: name, sort: name}));\n\n  // Return components and html elements\n  return uniqueByName(htmlElements.concat(components));\n}\n\nfunction entityCompletions(value: string, position: number): Completions|undefined {\n  // Look for entity completions\n  const re = /&[A-Za-z]*;?(?!\\d)/g;\n  let found: RegExpExecArray|null;\n  let result: Completions|undefined = undefined;\n  while (found = re.exec(value)) {\n    let len = found[0].length;\n    if (position >= found.index && position < (found.index + len)) {\n      result = Object.keys(NAMED_ENTITIES)\n                   .map<Completion>(name => ({kind: 'entity', name: `&${name};`, sort: name}));\n      break;\n    }\n  }\n  return result;\n}\n\nfunction interpolationCompletions(info: TemplateInfo, position: number): Completions|undefined {\n  // Look for an interpolation in at the position.\n  const templatePath = findTemplateAstAt(info.templateAst, position);\n  const mostSpecific = templatePath.tail;\n  if (mostSpecific) {\n    let visitor = new ExpressionVisitor(\n        info, position, undefined,\n        () => getExpressionScope(diagnosticInfoFromTemplateInfo(info), templatePath, false));\n    mostSpecific.visit(visitor, null);\n    return uniqueByName(visitor.result);\n  }\n}\n\n// There is a special case of HTML where text that contains a unclosed tag is treated as\n// text. For exaple '<h1> Some <a text </h1>' produces a text nodes inside of the H1\n// element \"Some <a text\". We, however, want to treat this as if the user was requesting\n// the attributes of an \"a\" element, not requesting completion in the a text element. This\n// code checks for this case and returns element completions if it is detected or undefined\n// if it is not.\nfunction voidElementAttributeCompletions(info: TemplateInfo, path: AstPath<HtmlAst>): Completions|\n    undefined {\n  let tail = path.tail;\n  if (tail instanceof Text) {\n    let match = tail.value.match(/<(\\w(\\w|\\d|-)*:)?(\\w(\\w|\\d|-)*)\\s/);\n    // The position must be after the match, otherwise we are still in a place where elements\n    // are expected (such as `<|a` or `<a|`; we only want attributes for `<a |` or after).\n    if (match &&\n        path.position >= (match.index || 0) + match[0].length + tail.sourceSpan.start.offset) {\n      return attributeCompletionsForElement(info, match[3]);\n    }\n  }\n}\n\nclass ExpressionVisitor extends NullTemplateVisitor {\n  private getExpressionScope: () => SymbolTable;\n  result: Completions;\n\n  constructor(\n      private info: TemplateInfo, private position: number, private attr?: Attribute,\n      getExpressionScope?: () => SymbolTable) {\n    super();\n    this.getExpressionScope = getExpressionScope || (() => info.template.members);\n  }\n\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst): void {\n    this.attributeValueCompletions(ast.value);\n  }\n\n  visitElementProperty(ast: BoundElementPropertyAst): void {\n    this.attributeValueCompletions(ast.value);\n  }\n\n  visitEvent(ast: BoundEventAst): void { this.attributeValueCompletions(ast.handler); }\n\n  visitElement(ast: ElementAst): void {\n    if (this.attr && getSelectors(this.info) && this.attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {\n      // The value is a template expression but the expression AST was not produced when the\n      // TemplateAst was produce so\n      // do that now.\n\n      const key = this.attr.name.substr(TEMPLATE_ATTR_PREFIX.length);\n\n      // Find the selector\n      const selectorInfo = getSelectors(this.info);\n      const selectors = selectorInfo.selectors;\n      const selector =\n          selectors.filter(s => s.attrs.some((attr, i) => i % 2 == 0 && attr == key))[0];\n\n      const templateBindingResult =\n          this.info.expressionParser.parseTemplateBindings(key, this.attr.value, null);\n\n      // find the template binding that contains the position\n      if (!this.attr.valueSpan) return;\n      const valueRelativePosition = this.position - this.attr.valueSpan.start.offset - 1;\n      const bindings = templateBindingResult.templateBindings;\n      const binding =\n          bindings.find(\n              binding => inSpan(valueRelativePosition, binding.span, /* exclusive */ true)) ||\n          bindings.find(binding => inSpan(valueRelativePosition, binding.span));\n\n      const keyCompletions = () => {\n        let keys: string[] = [];\n        if (selector) {\n          const attrNames = selector.attrs.filter((_, i) => i % 2 == 0);\n          keys = attrNames.filter(name => name.startsWith(key) && name != key)\n                     .map(name => lowerName(name.substr(key.length)));\n        }\n        keys.push('let');\n        this.result = keys.map(key => <Completion>{kind: 'key', name: key, sort: key});\n      };\n\n      if (!binding || (binding.key == key && !binding.expression)) {\n        // We are in the root binding. We should return `let` and keys that are left in the\n        // selector.\n        keyCompletions();\n      } else if (binding.keyIsVar) {\n        const equalLocation = this.attr.value.indexOf('=');\n        this.result = [];\n        if (equalLocation >= 0 && valueRelativePosition >= equalLocation) {\n          // We are after the '=' in a let clause. The valid values here are the members of the\n          // template reference's type parameter.\n          const directiveMetadata = selectorInfo.map.get(selector);\n          if (directiveMetadata) {\n            const contextTable =\n                this.info.template.query.getTemplateContext(directiveMetadata.type.reference);\n            if (contextTable) {\n              this.result = this.symbolsToCompletions(contextTable.values());\n            }\n          }\n        } else if (binding.key && valueRelativePosition <= (binding.key.length - key.length)) {\n          keyCompletions();\n        }\n      } else {\n        // If the position is in the expression or after the key or there is no key, return the\n        // expression completions\n        if ((binding.expression && inSpan(valueRelativePosition, binding.expression.ast.span)) ||\n            (binding.key &&\n             valueRelativePosition > binding.span.start + (binding.key.length - key.length)) ||\n            !binding.key) {\n          const span = new ParseSpan(0, this.attr.value.length);\n          this.attributeValueCompletions(\n              binding.expression ? binding.expression.ast :\n                                   new PropertyRead(span, new ImplicitReceiver(span), ''),\n              valueRelativePosition);\n        } else {\n          keyCompletions();\n        }\n      }\n    }\n  }\n\n  visitBoundText(ast: BoundTextAst) {\n    const expressionPosition = this.position - ast.sourceSpan.start.offset;\n    if (inSpan(expressionPosition, ast.value.span)) {\n      const completions = getExpressionCompletions(\n          this.getExpressionScope(), ast.value, expressionPosition, this.info.template.query);\n      if (completions) {\n        this.result = this.symbolsToCompletions(completions);\n      }\n    }\n  }\n\n  private attributeValueCompletions(value: AST, position?: number) {\n    const symbols = getExpressionCompletions(\n        this.getExpressionScope(), value, position == null ? this.attributeValuePosition : position,\n        this.info.template.query);\n    if (symbols) {\n      this.result = this.symbolsToCompletions(symbols);\n    }\n  }\n\n  private symbolsToCompletions(symbols: Symbol[]): Completions {\n    return symbols.filter(s => !s.name.startsWith('__') && s.public)\n        .map(symbol => <Completion>{kind: symbol.kind, name: symbol.name, sort: symbol.name});\n  }\n\n  private get attributeValuePosition() {\n    if (this.attr && this.attr.valueSpan) {\n      return this.position - this.attr.valueSpan.start.offset - 1;\n    }\n    return 0;\n  }\n}\n\nfunction getSourceText(template: TemplateSource, span: Span): string {\n  return template.source.substring(span.start, span.end);\n}\n\nfunction nameOfAttr(attr: AttrInfo): string {\n  let name = attr.name;\n  if (attr.output) {\n    name = removeSuffix(name, 'Events');\n    name = removeSuffix(name, 'Changed');\n  }\n  let result = [name];\n  if (attr.input) {\n    result.unshift('[');\n    result.push(']');\n  }\n  if (attr.output) {\n    result.unshift('(');\n    result.push(')');\n  }\n  if (attr.template) {\n    result.unshift('*');\n  }\n  return result.join('');\n}\n\nconst templateAttr = /^(\\w+:)?(template$|^\\*)/;\nfunction createElementCssSelector(element: Element): CssSelector {\n  const cssSelector = new CssSelector();\n  let elNameNoNs = splitNsName(element.name)[1];\n\n  cssSelector.setElement(elNameNoNs);\n\n  for (let attr of element.attrs) {\n    if (!attr.name.match(templateAttr)) {\n      let [_, attrNameNoNs] = splitNsName(attr.name);\n      cssSelector.addAttribute(attrNameNoNs, attr.value);\n      if (attr.name.toLowerCase() == 'class') {\n        const classes = attr.value.split(/s+/g);\n        classes.forEach(className => cssSelector.addClassName(className));\n      }\n    }\n  }\n  return cssSelector;\n}\n\nfunction foldAttrs(attrs: AttrInfo[]): AttrInfo[] {\n  let inputOutput = new Map<string, AttrInfo>();\n  let templates = new Map<string, AttrInfo>();\n  let result: AttrInfo[] = [];\n  attrs.forEach(attr => {\n    if (attr.fromHtml) {\n      return attr;\n    }\n    if (attr.template) {\n      let duplicate = templates.get(attr.name);\n      if (!duplicate) {\n        result.push({name: attr.name, template: true});\n        templates.set(attr.name, attr);\n      }\n    }\n    if (attr.input || attr.output) {\n      let duplicate = inputOutput.get(attr.name);\n      if (duplicate) {\n        duplicate.input = duplicate.input || attr.input;\n        duplicate.output = duplicate.output || attr.output;\n      } else {\n        let cloneAttr: AttrInfo = {name: attr.name};\n        if (attr.input) cloneAttr.input = true;\n        if (attr.output) cloneAttr.output = true;\n        result.push(cloneAttr);\n        inputOutput.set(attr.name, cloneAttr);\n      }\n    }\n  });\n  return result;\n}\n\nfunction expandedAttr(attr: AttrInfo): AttrInfo[] {\n  if (attr.input && attr.output) {\n    return [\n      attr, {name: attr.name, input: true, output: false},\n      {name: attr.name, input: false, output: true}\n    ];\n  }\n  return [attr];\n}\n\nfunction lowerName(name: string): string {\n  return name && (name[0].toLowerCase() + name.substr(1));\n}\n"]}