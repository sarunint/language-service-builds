{"version":3,"file":"diagnostics.js","sourceRoot":"","sources":["../../../../../packages/language-service/src/diagnostics.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgAnalyzedModules, StaticSymbol} from '@angular/compiler';\nimport {DiagnosticTemplateInfo, getTemplateExpressionDiagnostics} from '@angular/compiler-cli/src/language_services';\n\nimport {AstResult} from './common';\nimport {Declarations, Diagnostic, DiagnosticKind, DiagnosticMessageChain, Diagnostics, Span, TemplateSource} from './types';\nimport {offsetSpan, spanOf} from './utils';\n\nexport interface AstProvider {\n  getTemplateAst(template: TemplateSource, fileName: string): AstResult;\n}\n\nexport function getTemplateDiagnostics(\n    fileName: string, astProvider: AstProvider, templates: TemplateSource[]): Diagnostics {\n  const results: Diagnostics = [];\n  for (const template of templates) {\n    const ast = astProvider.getTemplateAst(template, fileName);\n    if (ast) {\n      if (ast.parseErrors && ast.parseErrors.length) {\n        results.push(...ast.parseErrors.map<Diagnostic>(\n            e => ({\n              kind: DiagnosticKind.Error,\n              span: offsetSpan(spanOf(e.span), template.span.start),\n              message: e.msg\n            })));\n      } else if (ast.templateAst && ast.htmlAst) {\n        const info: DiagnosticTemplateInfo = {\n          templateAst: ast.templateAst,\n          htmlAst: ast.htmlAst,\n          offset: template.span.start,\n          query: template.query,\n          members: template.members\n        };\n        const expressionDiagnostics = getTemplateExpressionDiagnostics(info);\n        results.push(...expressionDiagnostics);\n      }\n      if (ast.errors) {\n        results.push(...ast.errors.map<Diagnostic>(\n            e => ({kind: e.kind, span: e.span || template.span, message: e.message})));\n      }\n    }\n  }\n  return results;\n}\n\nexport function getDeclarationDiagnostics(\n    declarations: Declarations, modules: NgAnalyzedModules): Diagnostics {\n  const results: Diagnostics = [];\n\n  let directives: Set<StaticSymbol>|undefined = undefined;\n  for (const declaration of declarations) {\n    const report = (message: string | DiagnosticMessageChain, span?: Span) => {\n      results.push(<Diagnostic>{\n        kind: DiagnosticKind.Error,\n        span: span || declaration.declarationSpan, message\n      });\n    };\n    for (const error of declaration.errors) {\n      report(error.message, error.span);\n    }\n    if (declaration.metadata) {\n      if (declaration.metadata.isComponent) {\n        if (!modules.ngModuleByPipeOrDirective.has(declaration.type)) {\n          report(\n              `Component '${declaration.type.name}' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration`);\n        }\n        const {template, templateUrl} = declaration.metadata.template !;\n        if (template === null && !templateUrl) {\n          report(`Component '${declaration.type.name}' must have a template or templateUrl`);\n        } else if (template && templateUrl) {\n          report(\n              `Component '${declaration.type.name}' must not have both template and templateUrl`);\n        }\n      } else {\n        if (!directives) {\n          directives = new Set();\n          modules.ngModules.forEach(module => {\n            module.declaredDirectives.forEach(\n                directive => { directives !.add(directive.reference); });\n          });\n        }\n        if (!directives.has(declaration.type)) {\n          report(\n              `Directive '${declaration.type.name}' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration`);\n        }\n      }\n    }\n  }\n\n  return results;\n}\n"]}